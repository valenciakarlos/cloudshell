//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by TestShell Driver Builder Version 6.4.0.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#define TRACE
using System;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Diagnostics;
using System.Security.Permissions;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Proxies;
using System.Collections.Generic;
using System.ComponentModel;
using Microsoft.Win32;
using QualiSystems.Libraries;
using QualiSystems.Driver;

[assembly: AssemblyVersion("1.0.1259.14365")]
[assembly: AssemblyFileVersion("1.0.1259.14365")]
[assembly: AssemblyTitle("A project for creating a command-line application.\r\nExe applications require Runtime support.")]
[assembly: AssemblyProduct("[<AssemblyName>] 6.4.0")]
[assembly: Library(typeof(vcd_setup), "", IsolationLevel.PerLibrary)]




namespace QualiSystems.Driver
{
	[Description("A project for creating a command-line application.\r\nExe applications require Runtime support.")]
    public class vcd_setup : ICancelable, IDisposable
    {
        private static readonly Assembly DriverRuntimeAssembly;
        private static readonly string DriverRuntimeTypeName;
        private static readonly string DriverCodeBase;
		private Guid m_DriverIdentifier;
        
		private IFunctionInterpreter m_EntryPointFunctionInterpreter = null;
		private object m_EntryPointFunctionInterpreterLock = new object();

		
		static vcd_setup()
		{
			DriverCodeBase = Assembly.GetExecutingAssembly().CodeBase;
			TestShellRuntimeLocator runtimeLocator = new TestShellRuntimeLocator("6.4.0");
            DriverRuntimeAssembly = runtimeLocator.RuntimeAssembly;
            DriverRuntimeTypeName = runtimeLocator.RuntimeTypeName;
		}
		
		private void __Shutdown() 
		{
			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			runtimeType.GetMethod("Shutdown").Invoke(null, BindingFlags.Public | BindingFlags.Static, null, new object[0], null);
		}

        public vcd_setup()
        {
			m_DriverIdentifier = Guid.NewGuid();

			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			bool IsSupportedVersion = (bool)runtimeType.GetMethod("IsSupportedRuntimeVersion").Invoke(null, new object[]{"6.4.0"});
			if (!IsSupportedVersion)
				throw TestShellRuntimeLocator.NoMatchingRuntimeException("6.4.0");

			runtimeType.GetMethod("InitializeRuntime").Invoke(null, new object[]{Assembly.GetExecutingAssembly().CodeBase, "vcd_setup", m_DriverIdentifier.ToString()});
                      
			m_EntryPointFunctionInterpreter = CreateFunctionInterpreter("vcd_setup\\EntryPoint.tsdrv");

        }
        
        public static int Main(string[] args)
        {
            vcd_setup driverInstance = new vcd_setup();
            int retVal = (int)driverInstance.@EntryPoint(args);
            driverInstance.__Shutdown();
            return retVal;
        }
        
		[Hidden]
		public CancellationContext CreateCancellationContext()
		{
			return new CancellationContext();
		}

		[Hidden]
		public bool Cancel(CancellationContext cancellationContext)
		{
			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			return (bool)runtimeType.GetMethod("Cancel").Invoke(null, new object[]{cancellationContext.CallId});
		}

		[Hidden]
		public void Dispose()
		{
			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			runtimeType.GetMethod("DisposeDriverInstance").Invoke(null, new object[]{m_DriverIdentifier.ToString()});
		}

        private IFunctionInterpreter CreateFunctionInterpreter(string functionVirtualPath)
        {
            return new DucktypingProxy<IFunctionInterpreter>(DriverRuntimeAssembly.CreateInstance(
                    DriverRuntimeTypeName, false, BindingFlags.Default, null, new object[] { m_DriverIdentifier.ToString(), functionVirtualPath }, null, null)).TransparentProxy;
        }

		[Description("Main entry point for an executable")]
		[Cancelable]
		public int @EntryPoint([Alias("argsparam")]  string[] @argsparam)
		{
			lock(m_EntryPointFunctionInterpreterLock)
			{
				if(m_EntryPointFunctionInterpreter == null)
					m_EntryPointFunctionInterpreter = CreateFunctionInterpreter("vcd_setup\\EntryPoint.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["argsparam"] = @argsparam;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["Returnparam"] = typeof(int);
			Dictionary<string, object> outputNamesValues = m_EntryPointFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			return (int)outputNamesValues["Returnparam"];
		}


   
        #region DucktypingProxy
        
		[DebuggerStepThrough]
		internal class DucktypingProxy<TTarget> : RealProxy where TTarget : class
		{
			private object m_Target;

			public DucktypingProxy(object target) : base(typeof(TTarget))
			{
				m_Target = target;
			}

			[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
			public override IMessage Invoke(IMessage msg)
			{
				IMethodCallMessage methodMessage = new MethodCallMessageWrapper((IMethodCallMessage)msg);
				MethodBase method = methodMessage.MethodBase;
				object returnValue = null;
				ReturnMessage returnMessage = null;

				try
				{
					MethodBase targetMethod = GetTargetMethodFromInterfaceMethod(method);
					if (targetMethod == null)
						throw new NotImplementedException(string.Format("Method {0} was not implemented by the target", method.Name));
					returnValue = targetMethod.Invoke(m_Target, methodMessage.Args);
					returnMessage = new ReturnMessage(returnValue, methodMessage.Args, methodMessage.ArgCount, methodMessage.LogicalCallContext, methodMessage);
				}
				catch (Exception ex)
				{
					if ((ex is RemotingException || ex is TargetInvocationException)
						&& ex.InnerException != null)
						ex = ex.InnerException;

					returnMessage = new ReturnMessage(ex, methodMessage);
				}

				return returnMessage;
			}

			private MethodBase GetTargetMethodFromInterfaceMethod(MethodBase interfaceMethod)
			{
				ParameterInfo[] interfaceMethodParameters = interfaceMethod.GetParameters();
				Type[] parameterTypes = new Type[interfaceMethodParameters.Length];
				for (int i = 0; i < parameterTypes.Length; i++)
				{
					parameterTypes[i] = interfaceMethodParameters[i].ParameterType;
				}

				MethodInfo targetMethod;
				if (interfaceMethod.IsGenericMethod)
					targetMethod = m_Target.GetType().GetMethod(interfaceMethod.Name, parameterTypes).MakeGenericMethod(interfaceMethod.GetGenericArguments());
				else
					targetMethod = m_Target.GetType().GetMethod(interfaceMethod.Name, parameterTypes);

				return targetMethod;
			}

			public TTarget TransparentProxy
			{
				get
				{
					return base.GetTransparentProxy() as TTarget;
				}
			}
		}
		
		#endregion DucktypingProxy
		
		#region TestShellRuntimeLocator

        internal class TestShellRuntimeLocator
        {
            private const string RuntimeRepositoryPath = @"Software\QualiSystems\TestShellRuntime";

            public Assembly RuntimeAssembly { get; private set; }
            public string RuntimeTypeName { get; private set; }

            public TestShellRuntimeLocator(string targetRuntimeVersion)
            {
				Trace.WriteLine("Quali Runtime: Target runtime version is " +targetRuntimeVersion+ ", searching for matching installed versions...");
                var runtimeInfos = ReadInstalledTestShellRuntimeInfos(targetRuntimeVersion);
                TestShellRuntimeInfo selectedRuntimeInfo = SelectRuntimeVersionInfo(runtimeInfos, targetRuntimeVersion);
                RuntimeTypeName = selectedRuntimeInfo.RuntimeTypeName;
                string runtimeAssemblyPath = Path.Combine(selectedRuntimeInfo.Path, selectedRuntimeInfo.RuntimeAssemblyName);
                if (!System.IO.File.Exists(runtimeAssemblyPath))
                    throw RuntimeAssemblyNotFound(runtimeAssemblyPath);
                Trace.WriteLine("Quali Runtime: Loading runtime version " +selectedRuntimeInfo.Version+ " from " + runtimeAssemblyPath);
                RuntimeAssembly = Assembly.LoadFrom(runtimeAssemblyPath);
            }

            private static TestShellRuntimeInfo SelectRuntimeVersionInfo(IEnumerable<TestShellRuntimeInfo> runtimeInfos, string targetRuntimeVersion)
            {
                TestShellRuntimeInfo runtimeInfo = GetCurrentlyLoadedRuntimeInfo(runtimeInfos);
                if (runtimeInfo != null)
                {
                    if(!IsGreaterOrEqualVersion(runtimeInfo.Version, targetRuntimeVersion))
                        throw IncompatibleRuntimeLoaded(targetRuntimeVersion, runtimeInfo.Version);
                }
                else
                {
					var matchingRuntimeInfos = GetMatchingRuntimeInfos(runtimeInfos, targetRuntimeVersion);
					if (!matchingRuntimeInfos.Any())
						throw NoMatchingRuntimeException(targetRuntimeVersion);

					var licensedRuntimeInfos = GetLicensedRuntimeInfos(matchingRuntimeInfos);
					if (!licensedRuntimeInfos.Any())
						throw NoRuntimeLicenseException(targetRuntimeVersion);

                    runtimeInfo = GetBestMatchRuntimeInfo(licensedRuntimeInfos);
                }
                return runtimeInfo;
            }

			private static IEnumerable<TestShellRuntimeInfo> GetMatchingRuntimeInfos(IEnumerable<TestShellRuntimeInfo> runtimeInfos, string targetRuntimeVersion)
            {
				return runtimeInfos.
                    Where(r => IsGreaterOrEqualVersion(r.Version, targetRuntimeVersion)).	//only matching versions
					ToList();
			}
			
			private static IEnumerable<TestShellRuntimeInfo> GetLicensedRuntimeInfos(IEnumerable<TestShellRuntimeInfo> runtimeInfos)
			{
				return runtimeInfos.
					Where(IsLicenseValid).													//only licensed runtimes
					ToList();
			}

            private static TestShellRuntimeInfo GetBestMatchRuntimeInfo(IEnumerable<TestShellRuntimeInfo> runtimeInfos)
            {
                TestShellRuntimeInfo bestMatchRuntimeInfo = runtimeInfos.                    
                    OrderBy(r=>VersionStringToComparableNumber(r.Version)).FirstOrDefault();//best match
                return bestMatchRuntimeInfo;
            }

			private static bool IsLicenseValid(TestShellRuntimeInfo testShellRuntimeInfo)
			{
				string runtimeAssemblyPath = Path.Combine(testShellRuntimeInfo.Path, testShellRuntimeInfo.RuntimeAssemblyName);
				AppDomainSetup appDomainSetup = new AppDomainSetup();
				appDomainSetup.ApplicationBase = testShellRuntimeInfo.Path;
				AppDomain appDomain = AppDomain.CreateDomain("LicenseValidationDomain", AppDomain.CurrentDomain.Evidence, appDomainSetup);
				UnloadableLicenseValidator unloadableLicenseValidator = (UnloadableLicenseValidator)appDomain.CreateInstanceFromAndUnwrap(
                Assembly.GetExecutingAssembly().CodeBase, "QualiSystems.Driver.vcd_setup+TestShellRuntimeLocator+UnloadableLicenseValidator");
				bool isRuntimeLicenseValid = unloadableLicenseValidator.IsLicenseValid(runtimeAssemblyPath, testShellRuntimeInfo.RuntimeLicenseValidatorTypeName);
				AppDomain.Unload(appDomain);
				Trace.WriteLine("Quali Runtime: Runtime at " +testShellRuntimeInfo.Path+ " is " + (isRuntimeLicenseValid ? "Licensed" : "Unlicenced"));
				return isRuntimeLicenseValid;
			}

            private static bool IsGreaterOrEqualVersion(string comparedVersion, string baseVersion)
            {
                int comparedVersionWeighted = VersionStringToComparableNumber(comparedVersion);
                int baseVersionWeighted = VersionStringToComparableNumber(baseVersion);
                return comparedVersionWeighted >= baseVersionWeighted;
            }

            private static int VersionStringToComparableNumber(string version)
            {
                string[] versionParts = version.Split('.');
                int major = int.Parse(versionParts[0]);
                int minor = int.Parse(versionParts[1]);
                return (major << 16) + minor;
            }

            private static TestShellRuntimeInfo GetCurrentlyLoadedRuntimeInfo(IEnumerable<TestShellRuntimeInfo> readTestShellRuntimeInfo)
            {
                TestShellRuntimeInfo matchingRuntime = null;
                foreach (var loadedAssembly in AppDomain.CurrentDomain.GetAssemblies())
                {
                    try
                    {
                        matchingRuntime = readTestShellRuntimeInfo.FirstOrDefault(r => string.Equals(loadedAssembly.Location, Path.Combine(r.Path, r.RuntimeAssemblyName), StringComparison.InvariantCultureIgnoreCase));
                        if (matchingRuntime != null)
						{
							Trace.WriteLine("Quali Runtime: "+ string.Format("Runtime version {0} already loaded.", matchingRuntime.Version));
                            break;
						}
                    }
                    catch (NotSupportedException)
                    {}
                }
                return matchingRuntime;
            }

            private static IEnumerable<TestShellRuntimeInfo> ReadInstalledTestShellRuntimeInfos(string targetRuntimeVersion)
            {
                RegistryKey testShellRuntimeRepositoryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32).OpenSubKey(RuntimeRepositoryPath);
                if (testShellRuntimeRepositoryKey == null || testShellRuntimeRepositoryKey.SubKeyCount == 0)
                    throw NoMatchingRuntimeException(targetRuntimeVersion);

                List<TestShellRuntimeInfo> testShellRuntimeInfos = new List<TestShellRuntimeInfo>();
                foreach (var subKeyName in testShellRuntimeRepositoryKey.GetSubKeyNames())
                {
                    var runtimeKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32).OpenSubKey(Path.Combine(RuntimeRepositoryPath,subKeyName));
                    TestShellRuntimeInfo testShellRuntimeInfo = new TestShellRuntimeInfo();
                    testShellRuntimeInfo.Path = (string) runtimeKey.GetValue("Path");
                    testShellRuntimeInfo.Version = (string)runtimeKey.GetValue("RuntimeVersion") ?? (string)runtimeKey.GetValue("Version");
                    testShellRuntimeInfo.RuntimeAssemblyName = (string)runtimeKey.GetValue("RuntimeAssembly");
                    testShellRuntimeInfo.RuntimeTypeName = (string)runtimeKey.GetValue("RuntimeType");
                    testShellRuntimeInfo.RuntimeLicenseValidatorTypeName = (string)runtimeKey.GetValue("RuntimeLicenseValidatorType");
                    testShellRuntimeInfos.Add(testShellRuntimeInfo);
                }
                return testShellRuntimeInfos;
            }

            private static Exception IncompatibleRuntimeLoaded(string targetRuntimeVersion, string loadedRuntimeVersion)
            {
                return new ApplicationException(string.Format("Quali runtime version {0} needed but version {1} already loaded.", targetRuntimeVersion, loadedRuntimeVersion));
            }

            private static Exception RuntimeAssemblyNotFound(string runtimeAssemblyPath)
            {
                return new ApplicationException("Runtime assembly "+runtimeAssemblyPath+" is missing.");
            }

			public static Exception NoMatchingRuntimeException(string targetRuntimeVersion)
			{
				return TestShellRuntimeException("Could not find a matching TestShell Runtime with version " + targetRuntimeVersion,
												 targetRuntimeVersion,
												 "MatchingRuntimeNotFound");
			}

			private static Exception NoRuntimeLicenseException(string targetRuntimeVersion)
			{
				return TestShellRuntimeException("Could not find a license for TestShell Runtime version " + targetRuntimeVersion,
												 targetRuntimeVersion,
												 "RuntimeLicenseNotFound");
			}

			private static Exception TestShellRuntimeException(string description, string targetRuntimeVersion, string reason)
			{
				KeyValuePair<string, string>[] parameters = new[]
				{
					new KeyValuePair<string, string>("Target Version", targetRuntimeVersion),
					new KeyValuePair<string, string>("Reason", reason)
				};
				return new ErrorException("Quali Runtime", description, string.Empty, parameters);
			}

            private class TestShellRuntimeInfo
            {
                public string Path { get; set; }
                public string Version { get; set; }
                public string RuntimeAssemblyName { get; set; }
                public string RuntimeTypeName { get; set; }
                public string RuntimeLicenseValidatorTypeName { get; set; }
            }

			internal class UnloadableLicenseValidator : MarshalByRefObject
			{
				public bool IsLicenseValid(string runtimeAssemblyPath, string runtimeLicenseValidatorTypeName)
				{
					Assembly runtimeAssembly = Assembly.LoadFrom(runtimeAssemblyPath);
					Type runtimeLicenseValidatorType = runtimeAssembly.GetType(runtimeLicenseValidatorTypeName);
					bool isRuntimeLicenseValid = (bool)runtimeLicenseValidatorType.GetMethod("IsRuntimeLicenseValid").Invoke(null, null);
					return isRuntimeLicenseValid;
				}
			}
        }

        #endregion TestShellRuntimeLocator

		interface IFunctionInterpreter
		{
			Dictionary<string, object> Run(Guid callId, Dictionary<string, object> inputNamesValues, Dictionary<string, Type> outputNamesTypes);
		}
    }

	
}